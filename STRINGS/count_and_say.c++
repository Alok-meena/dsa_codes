The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = "1"
countAndSay(n) is the run-length encoding of countAndSay(n - 1).
Run-length encoding (RLE) is a string compression method that works by replacing consecutive identical
characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). 
For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". 
Thus the compressed string becomes "23321511".

Given a positive integer n, return the nth element of the count-and-say sequence.

 

Example 1:

Input: n = 4

Output: "1211"

Explanation:

countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"
Example 2:

Input: n = 1

Output: "1"






class Solution {
public:
    string countAndSay(int n) {
        if(n==1) return "1";
        if(n==2) return "11";
        string s="11";

        for(int i=3;i<=n;i++){
            string temp="";

            int count=1;
            for(int j=1;j<s.length();j++){
                if(s[j]!=s[j-1]){
                    temp+=to_string(count);
                    temp+=s[j-1];
                    count=1;
                }
                else{
                    count++;
                }
            }

            //this is necessary to include the last case when j>=s.length() can take the case when n=4
            temp += to_string(count);
            temp += s[s.length()-1]; //or can use s.back()
            s=temp;
        }

        return s;
    }
};

t.c:-o(2^n) and s.c:-O(L) where L--> length of the corresponding sequence



The sequence starts with "1" and each subsequent term is generated by describing the previous term. Here’s how the first few terms look:

1
11 (one 1)
21 (two 1s)
1211 (one 2, then one 1)
111221 (one 1, one 2, two 1s)
312211 (three 1s, two 2s, one 1)
Each term is constructed by reading the previous term and describing the counts of consecutive digits.

Growth of the Sequence
As you generate each new term, you count and say the digits of the previous term.
The length of each term grows based on the counts and values from the previous term.
Time Complexity Analysis
Length of Sequence:

Let's denote the length of the 
𝑖
i-th term by 
𝐿
(
𝑖
)
L(i).
The length of the sequence grows approximately by a factor of 1.3 to 1.5 times with each iteration. This is not exactly exponential but is significantly super-linear.
Operations per Character:

For each character in the term, you need to count its consecutive occurrences and form a new string based on these counts.
This means that constructing the next term involves processing each character of the current term.
Combined Effect:

If the length of the term at step 
𝑖
i is 
𝐿
(
𝑖
)
L(i), constructing the 
𝑖
+
1
i+1-th term involves 
𝑂
(
𝐿
(
𝑖
)
)
O(L(i)) operations.
Given the approximate growth factor, if the length grows as 
𝐿
(
𝑖
)
≈
1.
5
𝑖
L(i)≈1.5 
i
 , the total time to generate the 
𝑛
n-th term would involve summing up a geometric series of the form 
1
+
1.5
+
(
1.5
)
2
+
…
+
(
1.5
)
𝑛
−
1
1+1.5+(1.5) 
2
 +…+(1.5) 
n−1


class Solution {
public:
    string countAndSay(int n) {
        string ans="1";
        if(n==1) return ans;

        for(int i=0;i<n-1;i++){
            queue<char>q;
            for(auto i:ans){
                q.push(i);
            }

            string temp="";
            while(!q.empty()){
                char ch=q.front();
                cout<<ch<<" ";
                q.pop();

                int count=1;
                while(!q.empty()){
                    char c=q.front();
                    if(c!=ch) break;
                    count++;
                    q.pop();
                }
                temp+=to_string(count);
                temp.push_back(ch);
            }
            ans=temp;
        }
        
        return ans;
    }
};

my code t.c:-O(exponential)


or can do

 class Solution {
public:
    string countAndSay(int n) {
        string ans="1";

        for(int i=2;i<=n;i++){
            string s="";
            int j=0;
            while(j<ans.length()){
                int cnt=1;
                while(j+1<ans.length() and ans[j]==ans[j+1]){
                    cnt++;
                    j++;
                }
                s+=to_string(cnt)+ans[j];
                j++;
            }
            ans=s;
        }

        return ans;
    }
};
